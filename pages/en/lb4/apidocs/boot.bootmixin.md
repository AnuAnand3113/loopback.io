---
lang: en
title: 'API docs: boot.bootmixin'
keywords: LoopBack 4.0, LoopBack 4
sidebar: lb4_sidebar
editurl: https://github.com/strongloop/loopback-next/tree/master/packages/boot
permalink: /doc/en/lb4/apidocs.boot.bootmixin.html
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@loopback/boot](./boot.md) &gt; [BootMixin](./boot.bootmixin.md)

## BootMixin() function

Mixin for @<!-- -->loopback/boot. This Mixin provides the following: - Implements the Bootable Interface as follows. - Add a `projectRoot` property to the Class - Adds an optional `bootOptions` property to the Class that can be used to store the Booter conventions. - Adds the `BootComponent` to the Class (which binds the Bootstrapper and default Booters) - Provides the `boot()` convenience method to call Bootstrapper.boot() - Provides the `booter()` convenience method to bind a Booter(s) to the Application - Override `component()` to call `mountComponentBooters` - Adds `mountComponentBooters` which binds Booters to the application from `component.booters[]`

<b>Signature:</b>

```typescript
export declare function BootMixin<T extends MixinTarget<Application>>(superClass: T): {
    new (...args: any[]): {
        projectRoot: string;
        bootOptions?: BootOptions | undefined;
        boot(): Promise<void>;
        booters(...booterCls: Constructor<Booter>[]): Binding[];
        applicationBooter(subApp: Application & Bootable, filter?: BindingFilter | undefined): Binding<Booter>;
        component<C extends Component = Component>(componentCtor: Constructor<C>, nameOrOptions?: string | BindingFromClassOptions | undefined): Binding<C>;
        mountComponentBooters(component: Constructor<{}>): void;
        readonly options: ApplicationConfig;
        readonly state: string;
        controller: <T_1>(controllerCtor: Constructor<T_1>, nameOrOptions?: string | BindingFromClassOptions | undefined) => Binding<T_1>;
        server: <T_2 extends Server>(ctor: Constructor<T_2>, nameOrOptions?: string | BindingFromClassOptions | undefined) => Binding<T_2>;
        servers: <T_3 extends Server>(ctors: Constructor<T_3>[]) => Binding<any>[];
        getServer: <T_4 extends Server>(target: string | Constructor<T_4>) => Promise<T_4>;
        start: () => Promise<void>;
        stop: () => Promise<void>;
        setMetadata: (metadata: ApplicationMetadata) => void;
        lifeCycleObserver: <T_5 extends LifeCycleObserver>(ctor: Constructor<T_5>, nameOrOptions?: string | BindingFromClassOptions | undefined) => Binding<T_5>;
        service: <S>(cls: Constructor<S | Provider<S>>, nameOrOptions?: string | ServiceOptions | undefined) => Binding<S>;
        interceptor: (interceptor: Interceptor | Constructor<Provider<Interceptor>>, nameOrOptions?: string | InterceptorBindingOptions | undefined) => Binding<Interceptor>;
        readonly name: string;
        readonly subscriptionManager: ContextSubscriptionManager;
        readonly parent: Context | undefined;
        emitEvent: <T_6 extends ContextEvent>(type: string, event: T_6) => void;
        emitError: (err: unknown) => void;
        bind: <ValueType = any>(key: BindingAddress<ValueType>) => Binding<ValueType>;
        add: (binding: Binding<unknown>) => Application;
        configure: <ConfigValueType = any>(key?: string | BindingKey<unknown> | undefined) => Binding<ConfigValueType>;
        getConfigAsValueOrPromise: <ConfigValueType_1>(key: BindingAddress<unknown>, propertyPath?: string | undefined, resolutionOptions?: ResolutionOptions | undefined) => ValueOrPromise<ConfigValueType_1 | undefined>;
        getConfig: <ConfigValueType_2>(key: BindingAddress<unknown>, propertyPath?: string | undefined, resolutionOptions?: ResolutionOptions | undefined) => Promise<ConfigValueType_2 | undefined>;
        getConfigSync: <ConfigValueType_3>(key: BindingAddress<unknown>, propertyPath?: string | undefined, resolutionOptions?: ResolutionOptions | undefined) => ConfigValueType_3 | undefined;
        unbind: (key: BindingAddress<unknown>) => boolean;
        subscribe: (observer: ContextEventObserver) => Subscription;
        unsubscribe: (observer: ContextEventObserver) => boolean;
        close: () => void;
        isSubscribed: (observer: ContextObserver) => boolean;
        createView: <T_7 = unknown>(filter: BindingFilter, comparator?: BindingComparator | undefined) => ContextView<T_7>;
        contains: (key: BindingAddress<unknown>) => boolean;
        isBound: (key: BindingAddress<unknown>) => boolean;
        getOwnerContext: (key: BindingAddress<unknown>) => Context | undefined;
        find: <ValueType_1 = any>(pattern?: string | RegExp | BindingFilter | undefined) => Readonly<Binding<ValueType_1>>[];
        findByTag: <ValueType_2 = any>(tagFilter: string | RegExp | Record<string, any>) => Readonly<Binding<ValueType_2>>[];
        get: {
            <ValueType_3>(keyWithPath: BindingAddress<ValueType_3>, session?: ResolutionSession | undefined): Promise<ValueType_3>;
            <ValueType_4>(keyWithPath: BindingAddress<ValueType_4>, options: ResolutionOptions): Promise<ValueType_4 | undefined>;
        };
        getSync: {
            <ValueType_5>(keyWithPath: BindingAddress<ValueType_5>, session?: ResolutionSession | undefined): ValueType_5;
            <ValueType_6>(keyWithPath: BindingAddress<ValueType_6>, options?: ResolutionOptions | undefined): ValueType_6 | undefined;
        };
        getBinding: {
            <ValueType_7 = any>(key: BindingAddress<ValueType_7>): Binding<ValueType_7>;
            <ValueType_8>(key: BindingAddress<ValueType_8>, options?: {
                optional?: boolean | undefined;
            } | undefined): Binding<ValueType_8> | undefined;
        };
        findOrCreateBinding: <T_8>(key: BindingAddress<T_8>, policy?: BindingCreationPolicy | undefined) => Binding<T_8>;
        getValueOrPromise: <ValueType_9>(keyWithPath: BindingAddress<ValueType_9>, optionsOrSession?: ResolutionSession | ResolutionOptions | undefined) => ValueOrPromise<ValueType_9 | undefined>;
        toJSON: () => JSONObject;
        inspect: (options?: ContextInspectOptions | undefined) => JSONObject;
        addListener: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        on: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        once: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        prependListener: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        prependOnceListener: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        removeListener: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        off: (event: string | symbol, listener: (...args: any[]) => void) => Application;
        removeAllListeners: (event?: string | symbol | undefined) => Application;
        setMaxListeners: (n: number) => Application;
        getMaxListeners: () => number;
        listeners: (event: string | symbol) => Function[];
        rawListeners: (event: string | symbol) => Function[];
        emit: (event: string | symbol, ...args: any[]) => boolean;
        eventNames: () => (string | symbol)[];
        listenerCount: (type: string | symbol) => number;
    };
} & T;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  superClass | T |  |

<b>Returns:</b>

{ new (...args: any\[\]): { projectRoot: string; bootOptions?: [BootOptions](./boot.bootoptions.md) \| undefined; boot(): Promise&lt;void&gt;; booters(...booterCls: [Constructor](./context.constructor.md)<!-- -->&lt;[Booter](./boot.booter.md)<!-- -->&gt;\[\]): [Binding](./context.binding.md)<!-- -->\[\]; applicationBooter(subApp: [Application](./core.application.md) &amp; [Bootable](./boot.bootable.md)<!-- -->, filter?: [BindingFilter](./context.bindingfilter.md) \| undefined): [Binding](./context.binding.md)<!-- -->&lt;[Booter](./boot.booter.md)<!-- -->&gt;; component&lt;C extends [Component](./core.component.md) = [Component](./core.component.md)<!-- -->&gt;(componentCtor: [Constructor](./context.constructor.md)<!-- -->&lt;C&gt;, nameOrOptions?: string \| [BindingFromClassOptions](./context.bindingfromclassoptions.md) \| undefined): [Binding](./context.binding.md)<!-- -->&lt;C&gt;; mountComponentBooters(component: [Constructor](./context.constructor.md)<!-- -->&lt;{}&gt;): void; readonly options: [ApplicationConfig](./core.applicationconfig.md)<!-- -->; readonly state: string; controller: &lt;T\_1&gt;(controllerCtor: [Constructor](./context.constructor.md)<!-- -->&lt;T\_1&gt;, nameOrOptions?: string \| [BindingFromClassOptions](./context.bindingfromclassoptions.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;T\_1&gt;; server: &lt;T\_2 extends [Server](./core.server.md)<!-- -->&gt;(ctor: [Constructor](./context.constructor.md)<!-- -->&lt;T\_2&gt;, nameOrOptions?: string \| [BindingFromClassOptions](./context.bindingfromclassoptions.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;T\_2&gt;; servers: &lt;T\_3 extends [Server](./core.server.md)<!-- -->&gt;(ctors: [Constructor](./context.constructor.md)<!-- -->&lt;T\_3&gt;\[\]) =&gt; [Binding](./context.binding.md)<!-- -->&lt;any&gt;\[\]; getServer: &lt;T\_4 extends [Server](./core.server.md)<!-- -->&gt;(target: string \| [Constructor](./context.constructor.md)<!-- -->&lt;T\_4&gt;) =&gt; Promise&lt;T\_4&gt;; start: () =&gt; Promise&lt;void&gt;; stop: () =&gt; Promise&lt;void&gt;; setMetadata: (metadata: [ApplicationMetadata](./core.applicationmetadata.md)<!-- -->) =&gt; void; lifeCycleObserver: &lt;T\_5 extends [LifeCycleObserver](./core.lifecycleobserver.md)<!-- -->&gt;(ctor: [Constructor](./context.constructor.md)<!-- -->&lt;T\_5&gt;, nameOrOptions?: string \| [BindingFromClassOptions](./context.bindingfromclassoptions.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;T\_5&gt;; service: &lt;S&gt;(cls: [Constructor](./context.constructor.md)<!-- -->&lt;S \| [Provider](./context.provider.md)<!-- -->&lt;S&gt;&gt;, nameOrOptions?: string \| [ServiceOptions](./core.serviceoptions.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;S&gt;; interceptor: (interceptor: [Interceptor](./context.interceptor.md) \| [Constructor](./context.constructor.md)<!-- -->&lt;[Provider](./context.provider.md)<!-- -->&lt;[Interceptor](./context.interceptor.md)<!-- -->&gt;&gt;, nameOrOptions?: string \| [InterceptorBindingOptions](./context.interceptorbindingoptions.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;[Interceptor](./context.interceptor.md)<!-- -->&gt;; readonly name: string; readonly subscriptionManager: [ContextSubscriptionManager](./context.contextsubscriptionmanager.md)<!-- -->; readonly parent: [Context](./context.context.md) \| undefined; emitEvent: &lt;T\_6 extends [ContextEvent](./context.contextevent.md)<!-- -->&gt;(type: string, event: T\_6) =&gt; void; emitError: (err: unknown) =&gt; void; bind: &lt;ValueType = any&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType&gt;) =&gt; [Binding](./context.binding.md)<!-- -->&lt;ValueType&gt;; add: (binding: [Binding](./context.binding.md)<!-- -->&lt;unknown&gt;) =&gt; [Application](./core.application.md)<!-- -->; configure: &lt;ConfigValueType = any&gt;(key?: string \| [BindingKey](./context.bindingkey.md)<!-- -->&lt;unknown&gt; \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;ConfigValueType&gt;; getConfigAsValueOrPromise: &lt;ConfigValueType\_1&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;, propertyPath?: string \| undefined, resolutionOptions?: [ResolutionOptions](./context.resolutionoptions.md) \| undefined) =&gt; [ValueOrPromise](./context.valueorpromise.md)<!-- -->&lt;ConfigValueType\_1 \| undefined&gt;; getConfig: &lt;ConfigValueType\_2&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;, propertyPath?: string \| undefined, resolutionOptions?: [ResolutionOptions](./context.resolutionoptions.md) \| undefined) =&gt; Promise&lt;ConfigValueType\_2 \| undefined&gt;; getConfigSync: &lt;ConfigValueType\_3&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;, propertyPath?: string \| undefined, resolutionOptions?: [ResolutionOptions](./context.resolutionoptions.md) \| undefined) =&gt; ConfigValueType\_3 \| undefined; unbind: (key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;) =&gt; boolean; subscribe: (observer: [ContextEventObserver](./context.contexteventobserver.md)<!-- -->) =&gt; [Subscription](./context.subscription.md)<!-- -->; unsubscribe: (observer: [ContextEventObserver](./context.contexteventobserver.md)<!-- -->) =&gt; boolean; close: () =&gt; void; isSubscribed: (observer: [ContextObserver](./context.contextobserver.md)<!-- -->) =&gt; boolean; createView: &lt;T\_7 = unknown&gt;(filter: [BindingFilter](./context.bindingfilter.md)<!-- -->, comparator?: [BindingComparator](./context.bindingcomparator.md) \| undefined) =&gt; [ContextView](./context.contextview.md)<!-- -->&lt;T\_7&gt;; contains: (key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;) =&gt; boolean; isBound: (key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;) =&gt; boolean; getOwnerContext: (key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;unknown&gt;) =&gt; [Context](./context.context.md) \| undefined; find: &lt;ValueType\_1 = any&gt;(pattern?: string \| RegExp \| [BindingFilter](./context.bindingfilter.md) \| undefined) =&gt; Readonly&lt;[Binding](./context.binding.md)<!-- -->&lt;ValueType\_1&gt;&gt;\[\]; findByTag: &lt;ValueType\_2 = any&gt;(tagFilter: string \| RegExp \| Record&lt;string, any&gt;) =&gt; Readonly&lt;[Binding](./context.binding.md)<!-- -->&lt;ValueType\_2&gt;&gt;\[\]; get: { &lt;ValueType\_3&gt;(keyWithPath: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_3&gt;, session?: [ResolutionSession](./context.resolutionsession.md) \| undefined): Promise&lt;ValueType\_3&gt;; &lt;ValueType\_4&gt;(keyWithPath: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_4&gt;, options: [ResolutionOptions](./context.resolutionoptions.md)<!-- -->): Promise&lt;ValueType\_4 \| undefined&gt;; }; getSync: { &lt;ValueType\_5&gt;(keyWithPath: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_5&gt;, session?: [ResolutionSession](./context.resolutionsession.md) \| undefined): ValueType\_5; &lt;ValueType\_6&gt;(keyWithPath: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_6&gt;, options?: [ResolutionOptions](./context.resolutionoptions.md) \| undefined): ValueType\_6 \| undefined; }; getBinding: { &lt;ValueType\_7 = any&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_7&gt;): [Binding](./context.binding.md)<!-- -->&lt;ValueType\_7&gt;; &lt;ValueType\_8&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_8&gt;, options?: { optional?: boolean \| undefined; } \| undefined): [Binding](./context.binding.md)<!-- -->&lt;ValueType\_8&gt; \| undefined; }; findOrCreateBinding: &lt;T\_8&gt;(key: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;T\_8&gt;, policy?: [BindingCreationPolicy](./context.bindingcreationpolicy.md) \| undefined) =&gt; [Binding](./context.binding.md)<!-- -->&lt;T\_8&gt;; getValueOrPromise: &lt;ValueType\_9&gt;(keyWithPath: [BindingAddress](./context.bindingaddress.md)<!-- -->&lt;ValueType\_9&gt;, optionsOrSession?: [ResolutionSession](./context.resolutionsession.md) \| [ResolutionOptions](./context.resolutionoptions.md) \| undefined) =&gt; [ValueOrPromise](./context.valueorpromise.md)<!-- -->&lt;ValueType\_9 \| undefined&gt;; toJSON: () =&gt; [JSONObject](./context.jsonobject.md)<!-- -->; inspect: (options?: [ContextInspectOptions](./context.contextinspectoptions.md) \| undefined) =&gt; [JSONObject](./context.jsonobject.md)<!-- -->; addListener: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; on: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; once: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; prependListener: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; prependOnceListener: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; removeListener: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; off: (event: string \| symbol, listener: (...args: any\[\]) =&gt; void) =&gt; [Application](./core.application.md)<!-- -->; removeAllListeners: (event?: string \| symbol \| undefined) =&gt; [Application](./core.application.md)<!-- -->; setMaxListeners: (n: number) =&gt; [Application](./core.application.md)<!-- -->; getMaxListeners: () =&gt; number; listeners: (event: string \| symbol) =&gt; Function\[\]; rawListeners: (event: string \| symbol) =&gt; Function\[\]; emit: (event: string \| symbol, ...args: any\[\]) =&gt; boolean; eventNames: () =&gt; (string \| symbol)\[\]; listenerCount: (type: string \| symbol) =&gt; number; }; } &amp; T


