"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([[5725],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,m=h["".concat(p,".").concat(u)]||h[u]||d[u]||i;return n?a.createElement(m,o(o({ref:t},s),{},{components:n})):a.createElement(m,o({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2476:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return c},assets:function(){return s},toc:function(){return d},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={title:"Building an Online Game With LoopBack 4 - Customizing APIs in Controller (Part 3)",date:new Date("2019-05-28T00:00:00.000Z"),authors:"wenbo",slug:"building-an-online-game-with-loopback-4-pt3",tags:["how-to"]},p=void 0,c={permalink:"/blog/building-an-online-game-with-loopback-4-pt3",editUrl:"https://github.com/loopbackio/loopback-blog/blog/2019/2019-05-28-building-an-online-game-with-loopback-4-pt3.md",source:"@site/blog/2019/2019-05-28-building-an-online-game-with-loopback-4-pt3.md",title:"Building an Online Game With LoopBack 4 - Customizing APIs in Controller (Part 3)",description:"Part 3: Customizing APIs in Controller",date:"2019-05-28T00:00:00.000Z",formattedDate:"May 28, 2019",tags:[{label:"how-to",permalink:"/blog/tags/how-to"}],readingTime:7.66,truncated:!0,authors:[{name:"Wen Bo",title:"LoopBack Maintainer",url:"https://github.com/gobackhuoxing",imageURL:"https://avatars.githubusercontent.com/u/22156589",key:"wenbo"}],frontMatter:{title:"Building an Online Game With LoopBack 4 - Customizing APIs in Controller (Part 3)",date:"2019-05-28T00:00:00.000Z",authors:"wenbo",slug:"building-an-online-game-with-loopback-4-pt3",tags:["how-to"]},prevItem:{title:"LoopBack 4 May 2019 Milestone Update",permalink:"/blog/may-2019-milestone"},nextItem:{title:"Building an Online Game With LoopBack 4, Part 2 - Generating Universally Unique ID and Managing Models Relationships",permalink:"/blog/building-an-online-game-with-loopback-4-pt2"}},s={authorsImageUrls:[void 0]},d=[{value:"Part 3: Customizing APIs in Controller",id:"part-3-customizing-apis-in-controller",children:[{value:"Introduction",id:"introduction",children:[],level:3},{value:"Previously on Building an Online Game With LoopBack 4",id:"previously-on-building-an-online-game-with-loopback-4",children:[],level:3},{value:"In This Episode",id:"in-this-episode",children:[],level:3},{value:"Create Controller",id:"create-controller",children:[],level:3},{value:"Equip Character",id:"equip-character",children:[],level:3},{value:"Unequip Character",id:"unequip-character",children:[],level:3},{value:"Levelling Up a Character",id:"levelling-up-a-character",children:[],level:3},{value:"Check Character Information",id:"check-character-information",children:[],level:3},{value:"Applying This to Your Own Project",id:"applying-this-to-your-own-project",children:[],level:3},{value:"What&#39;s Next?",id:"whats-next",children:[],level:3}],level:2}],h={toc:d};function u(e){var t=e.components,l=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},h,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"part-3-customizing-apis-in-controller"},"Part 3: Customizing APIs in Controller"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"In this series, I\u2019m going to help you learn LoopBack 4 and how to use it to easily build your own API and web project. We\u2019ll create a new project I\u2019ve been working on: an online web text-based adventure game. In this game, you can create your own account to build characters, fight monsters and find treasures. You will be able to control your character to take a variety of actions: attacking enemies, casting spells, and getting loot. This game also allows multiple players to log in and play with their friends."),(0,i.kt)("h3",{id:"previously-on-building-an-online-game-with-loopback-4"},"Previously on Building an Online Game With LoopBack 4"),(0,i.kt)("p",null,"In the last episode, we used a third-party library to generate UUID and built relations between ",(0,i.kt)("inlineCode",{parentName:"p"},"character"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"weapon"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"armor"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"skill"),"."),(0,i.kt)("p",null,"Here are the previous episodes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://strongloop.com/strongblog/building-online-game-with-loopback-4-pt1/"},"Part 1: Building a Simple LoopBack Project With MongoDB")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://strongloop.com/strongblog/building-an-online-game-with-loopback-4-pt2/"},"Part 2: Generating Universally Unique ID and Managing Models Relationships"))),(0,i.kt)("h3",{id:"in-this-episode"},"In This Episode"),(0,i.kt)("p",null,"We already have some simple APIs in our project. They are all default CRUD (Create, Read, Update, and Delete) APIs that auto-generated by LoopBack 4. In this episode, we will create our own APIs to achieve the following functions for character updating:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"models",src:n(2705).Z,width:"1206",height:"826"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ability for users to equip their character with weapon, armor, and skill. This function should also be able to allow users to change weapon, armor, and skill for their character. In any of these cases, we should update ",(0,i.kt)("inlineCode",{parentName:"li"},"defence")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"attack")," accordingly."),(0,i.kt)("li",{parentName:"ul"},"The ability for users to unequip their character. We also need to update ",(0,i.kt)("inlineCode",{parentName:"li"},"defence")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"attack"),"."),(0,i.kt)("li",{parentName:"ul"},"The ability to level up a character when it gets enough experience. We should update ",(0,i.kt)("inlineCode",{parentName:"li"},"currentExp"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"nextLevelExp"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"level"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"maxHealth"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"currentHealth"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"maxMana"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"currentMana"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"attack"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"defence"),"."),(0,i.kt)("li",{parentName:"ul"},"The ability to check a character's ",(0,i.kt)("inlineCode",{parentName:"li"},"weapon"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"armor"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"skill")," information.")),(0,i.kt)("h3",{id:"create-controller"},"Create Controller"),(0,i.kt)("p",null,"First, let's create a controller for updating your character. Run ",(0,i.kt)("inlineCode",{parentName:"p"},"lb4 controller")," in your project root."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"wenbo:firstgame wenbo$ lb4 controller\n? Controller class name: UpdateCharacter\n? What kind of controller would you like to generate? REST Controller with CRUD functions\n? What is the name of the model to use with this CRUD repository? Character\n? What is the name of your CRUD repository? CharacterRepository\n? What is the type of your ID? string\n? What is the base HTTP path name of the CRUD operations? /updatecharacter\n   create src/controllers/update-character.controller.ts\n   update src/controllers/index.ts\n\nController UpdateCharacter was created in src/controllers/\n")),(0,i.kt)("p",null,"Open ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/controllers/update-character.controller.ts"),". Add the following imports because this controller is\nassociated with ",(0,i.kt)("inlineCode",{parentName:"p"},"Armor"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Weapon"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"skill")," as well."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Armor, Weapon, Skill} from '../models';\nimport {WeaponRepository, ArmorRepository, SkillRepository } from '../repositories';\n")),(0,i.kt)("p",null,"Then add the following lines into constructor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(\n  @repository(CharacterRepository)\n  public characterRepository : CharacterRepository,\n\n  //add following lines\n  @repository(WeaponRepository)\n  public weaponRepository : WeaponRepository,\n  @repository(ArmorRepository)\n  public armorRepository : ArmorRepository,\n  @repository(SkillRepository)\n  public skillRepository : SkillRepository,\n) {}\n\n")),(0,i.kt)("p",null,"This will connect this controller with ",(0,i.kt)("inlineCode",{parentName:"p"},"Armor"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Weapon"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"skill"),". You can now delete all those default APIs since we don't need them anymore."),(0,i.kt)("h3",{id:"equip-character"},"Equip Character"),(0,i.kt)("p",null,"The first API we need is ",(0,i.kt)("inlineCode",{parentName:"p"},"@patch '/updatecharacter/{id}/weapon'"),". In this game, a character can only have one weapon. With that in mind, this API's job is to equip characters with a weapon and unequip the old weapon if there is one."),(0,i.kt)("p",null,"Here is code for this API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@patch('/updatecharacter/{id}/weapon', {\n  responses: {\n    '200': {\n      description: 'update weapon',\n      content: {'application/json': {schema: Weapon}},\n    },\n  },\n})\nasync updateWeapon(\n  @param.path.string('id') id: string,\n  @requestBody() weapon: Weapon,\n): Promise<Weapon> {\n  //equip new weapon\n  let char: Character = await this.characterRepository.findById(id);\n  char.attack! += weapon.attack;\n  char.defence! += weapon.defence;\n\n  //unequip old weapon\n  let filter: Filter = {where:{\"characterId\":id}};\n  if((await this.weaponRepository.find(filter))[0] != undefined){\n    let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();\n    char.attack! -= oldWeapon.attack;\n    char.defence! -= oldWeapon.defence;\n    await this.characterRepository.weapon(id).delete();\n  }\n  await this.characterRepository.updateById(id, char);\n  return await this.characterRepository.weapon(id).create(weapon);\n}\n")),(0,i.kt)("p",null,"Let's go over it line by line."),(0,i.kt)("p",null,"This is the function signature. It means this API expects to get a character ID from URL and weapon entity from body."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"async updateWeapon(\n  @param.path.string('id') id: string,\n  @requestBody() weapon: Weapon,\n): Promise<Weapon> {\n\n  ...\n")),(0,i.kt)("p",null,"The following lines will find the character entity from our database. Then we will update this character's ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," after ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence")," tells the compiler we guarantee those variables are not undefined. Otherwise, we will get a compile error. In the ",(0,i.kt)("inlineCode",{parentName:"p"},"weapon")," model, ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence")," are both required, so these cannot be empty."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"//equip new weapon\nlet char: Character = await this.characterRepository.findById(id);\nchar.attack! += weapon.attack;\nchar.defence! += weapon.defence;\n")),(0,i.kt)("p",null,"This block will check if this character already has a weapon. If so, it will update the character's ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence")," and remove the old weapon from database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'//unequip old weapon\nlet filter: Filter = {where:{"characterId":id}};\nif((await this.weaponRepository.find(filter))[0] != undefined){\n  let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();\n  char.attack! -= oldWeapon.attack;\n  char.defence! -= oldWeapon.defence;\n  await this.characterRepository.weapon(id).delete();\n}\n')),(0,i.kt)("p",null,"Those two lines will update the update character information in our database and put the new weapon into it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"await this.characterRepository.updateById(id, char);\nreturn await this.characterRepository.weapon(id).create(weapon);\n")),(0,i.kt)("p",null,"We need to handle ",(0,i.kt)("inlineCode",{parentName:"p"},"armor")," exactly the same. But ",(0,i.kt)("inlineCode",{parentName:"p"},"skill")," is a little bit different, because in this game ",(0,i.kt)("inlineCode",{parentName:"p"},"skill")," will not influence ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence"),". We just need to update our new skill and delete the old skill."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@patch('/updatecharacter/{id}/skill', {\n  responses: {\n    '200': {\n      description: 'update skill',\n      content: {'application/json': {schema: Skill}},\n    },\n  },\n})\nasync updateSkill(\n  @param.path.string('id') id: string,\n  @requestBody() skill: Skill,\n): Promise<Skill> {\n  await this.characterRepository.skill(id).delete();\n  return await this.characterRepository.skill(id).create(skill);\n}\n")),(0,i.kt)("p",null,"When we delete a character, we also need to delete its ",(0,i.kt)("inlineCode",{parentName:"p"},"weapon"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"armor"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"skill"),". To do this, open ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/controllers/character.controller.ts")," and add the following lines in ",(0,i.kt)("inlineCode",{parentName:"p"},"del '/characters/{id}")," API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@del('/characters/{id}', {\n  responses: {\n    '204': {\n      description: 'Character DELETE success',\n    },\n  },\n})\nasync deleteById(\n  @param.path.string('id') id: string\n): Promise<void> {\n  //delete weapon, armor, and skill\n  await this.characterRepository.weapon(id).delete();\n  await this.characterRepository.armor(id).delete();\n  await this.characterRepository.skill(id).delete();\n  ///\n  await this.characterRepository.deleteById(id);\n}\n")),(0,i.kt)("h3",{id:"unequip-character"},"Unequip Character"),(0,i.kt)("p",null,"Unequipping the character is very easy."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"weapon")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"armor"),", simply remove them from database and update ",(0,i.kt)("inlineCode",{parentName:"p"},"attack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"defence"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@del('/updatecharacter/{id}/weapon', {\n  responses: {\n    '204': {\n      description: 'DELETE Weapon',\n    },\n  },\n})\nasync deleteWeapon(\n  @param.path.string('id') id: string\n): Promise<void> {\n  //unequip old weapon\n  let filter: Filter = {where:{\"characterId\":id}};\n  if((await this.weaponRepository.find(filter))[0] != undefined){\n    let oldWeapon: Weapon = await this.characterRepository.weapon(id).get();\n    let char: Character = await this.characterRepository.findById(id);\n    char.attack! -= oldWeapon.attack!;\n    char.defence! -= oldWeapon.defence!;\n    await this.characterRepository.weapon(id).delete();\n    await this.characterRepository.updateById(id, char);\n  }\n}\n")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"skill"),", just remove it from database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@del('/updatecharacter/{id}/skill', {\n  responses: {\n    '204': {\n      description: 'DELETE Skill',\n    },\n  },\n})\nasync deleteSkill(\n  @param.path.string('id') id: string\n): Promise<void> {\n    await this.characterRepository.skill(id).delete();\n}\n")),(0,i.kt)("h3",{id:"levelling-up-a-character"},"Levelling Up a Character"),(0,i.kt)("p",null,"When a character has enough experience, we reward it by levelling up. In ",(0,i.kt)("inlineCode",{parentName:"p"},"/src/controllers/update-character.controller.ts"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@patch('/updatecharacter/{id}/levelup', {\n  responses: {\n    '200': {\n      description: 'level up',\n      content: {'application/json': {schema: Character}},\n    },\n  },\n})\nasync levelUp(@param.path.string('id') id: string): Promise<Character> {\n    let char: Character = await this.characterRepository.findById(id);\n    let levels: number = 0;\n    while(char.currentExp! >= char.nextLevelExp!){\n      levels++;\n      char.currentExp! -= char.nextLevelExp!;\n      char.nextLevelExp! += 100;\n    }\n    char.level! += levels;\n    char.maxHealth! += 10 * levels;\n    char.currentHealth! = char.maxHealth!;\n    char.maxMana! += 5 * levels;\n    char.currentMana! = char.maxMana!;\n    char.attack! += 3 * levels;\n    char.defence! += levels;\n    await this.characterRepository!.updateById(id, char);\n    return char;\n}\n")),(0,i.kt)("p",null,"Let's go over this line by line."),(0,i.kt)("p",null,"If a character just beat a very strong enemy and gained a lot of experience, it could level up more than once. So the first thing we need to do is figure out how many times we need to level up."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let levels: number = 0;\nwhile(char.currentExp! >= char.nextLevelExp!){\n  levels++;\n  char.currentExp! -= char.nextLevelExp!;\n  char.nextLevelExp! += 100;\n}\n")),(0,i.kt)("p",null,"Then we can update everything accordingly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"char.level! += levels;\nchar.maxHealth! += 10 * levels;\nchar.currentHealth! = char.maxHealth!;\nchar.maxMana! += 5 * levels;\nchar.currentMana! = char.maxMana!;\nchar.attack! += 3 * levels;\nchar.defence! += levels;\n")),(0,i.kt)("p",null,"Lastly, we update this character in database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"await this.characterRepository!.updateById(id, char);\n")),(0,i.kt)("h3",{id:"check-character-information"},"Check Character Information"),(0,i.kt)("p",null,"The last function we need to achieve is the ability to check character information."),(0,i.kt)("p",null,"Here is the code for this API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@get('/updatecharacter/{id}', {\n  responses: {\n    '200': {\n      description: 'armor, weapon, and skill info',\n      content: {},\n    },\n  },\n})\nasync findById(\n  @param.path.string('id') id: string,\n): Promise<any[]> {\n  let res: any[] = ['no weapon', 'no armor', 'no skill'];\n\n  let filter: Filter = {where:{\"characterId\":id}};\n  if((await this.weaponRepository.find(filter))[0] != undefined){\n    res[0] = await this.characterRepository.weapon(id).get()\n  }\n  if((await this.armorRepository.find(filter))[0] != undefined){\n    res[1] = await this.characterRepository.armor(id).get()\n  }\n  if((await this.skillRepository.find(filter))[0] != undefined){\n    res[2] = await this.characterRepository.skill(id).get()\n  }\n  return res;\n}\n\n")),(0,i.kt)("p",null,"We first create an array contains three elements: 'no weapon', 'no armor', 'no skill'."),(0,i.kt)("p",null,"Then we will check our database. For example, if this character has a weapon, we will replace ",(0,i.kt)("inlineCode",{parentName:"p"},"no weapon")," with the weapon information. Lastly, we return the array as result."),(0,i.kt)("p",null,"That is all we want to achieve in this episode. If you can follow all those steps, you should be able to try those API at ",(0,i.kt)("a",{parentName:"p",href:"http://%5B::1%5D:3000"},"http://[::1]:3000")),(0,i.kt)("p",null,"You can check ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gobackhuoxing/first-web-game-lb4/tree/part3/firstgame"},"here")," for the code of this episode."),(0,i.kt)("h3",{id:"applying-this-to-your-own-project"},"Applying This to Your Own Project"),(0,i.kt)("p",null,"In this episode, we covered the how to customize APIs. You can always implement your own amazing idea in your LoopBack 4 project."),(0,i.kt)("h3",{id:"whats-next"},"What's Next?"),(0,i.kt)("p",null,"In next episode, we will add user authentication and role-based access control to this project."),(0,i.kt)("p",null,"In the meantime, you can learn more about LoopBack in ",(0,i.kt)("a",{parentName:"p",href:"https://strongloop.com/strongblog/tag_LoopBack.html"},"past blogs"),"."))}u.isMDXComponent=!0},2705:function(e,t,n){t.Z=n.p+"assets/images/my-first-api-p2-models-f5854d7c955356bd60e51ef60dbc2ba1.png"}}]);